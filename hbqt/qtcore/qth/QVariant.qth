/*
 * $Id: QVariant.qth 406 2015-02-21 01:11:53Z bedipritpal $
 */

/*
 * Harbour Qt wrapper generator control file
 *
 * Copyright 2009-2012 Pritpal Bedi <bedipritpal@hotmail.com>
 * www - http://www.harbour-project.org
 *
 * See COPYING for licensing terms.
 */

<CLASS>
QObject     = no
Type        = Core
New         =
</CLASS>

<CODE>
#include <QtCore/QLine>
#include <QtCore/QRect>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtCore/QBitArray>
#include <QtCore/QTime>
#include <QtCore/QUrl>
#include <QtCore/QLocale>


/*
QVariant ()
QVariant ( Qt::GlobalColor color )
QVariant ( Type type )
QVariant ( int typeOrUserType, const void * copy )
QVariant ( const QVariant & p )
QVariant ( QDataStream & s )
QVariant ( int val )
QVariant ( uint val )
QVariant ( qlonglong val )
QVariant ( qulonglong val )
QVariant ( bool val )
QVariant ( double val )
QVariant ( const char * val )
QVariant ( const QByteArray & val )
QVariant ( const QBitArray & val )
QVariant ( const QString & val )
QVariant ( const QLatin1String & val )
QVariant ( const QStringList & val )
QVariant ( const QChar & c )
QVariant ( const QDate & val )
QVariant ( const QTime & val )
QVariant ( const QDateTime & val )
QVariant ( const QList<QVariant> & val )
QVariant ( const QMap<QString, QVariant> & val )
QVariant ( const QHash<QString, QVariant> & val )
QVariant ( const QSize & val )
QVariant ( const QSizeF & val )
QVariant ( const QPoint & val )
QVariant ( const QPointF & val )
QVariant ( const QLine & val )
QVariant ( const QLineF & val )
QVariant ( const QRect & val )
QVariant ( const QRectF & val )
QVariant ( const QUrl & val )
QVariant ( const QLocale & l )
QVariant ( const QRegExp & regExp )
~QVariant ()
 */
HB_FUNC( QT_QVARIANT )
{
   if( hb_pcount() == 1 && HB_ISOBJECT( 1 ) )
   {
      if( hbqt_par_isDerivedFrom( 1, "QVARIANT" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QVariant( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QBYTEARRAY" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QByteArray( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QBITARRAY" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QBitArray( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QLATIN1STRING" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QLatin1String( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QSTRINGLIST" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QStringList( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QDATE" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QDate( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QTIME" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QTime( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QDATETIME" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QDateTime( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QCHAR" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QChar( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QSIZE" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QSize( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QSIZEF" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QSizeF( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QRECT" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QRect( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QRECTF" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QRectF( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QPOINT" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QPoint( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QPOINTF" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QPointF( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QLINE" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QLine( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QLINEF" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QLineF( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QURL" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QUrl( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QLOCALE" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QLocale( 1 ) ) );
      }
      else if( hbqt_par_isDerivedFrom( 1, "QREGEXP" ) )
      {
         __HB_RETPTRGC__( new QVariant( *hbqt_par_QRegExp( 1 ) ) );
      }
   }
   else if( hb_pcount() == 1 && HB_ISCHAR( 1 ) )
   {
      void * pText01 = NULL;
      __HB_RETPTRGC__( new QVariant( hb_parstr_utf8( 1, &pText01, NULL ) ) );
      hb_strfree( pText01 );
   }
   else if( hb_pcount() == 1 && HB_ISNUM( 1 ) )
   {  
      if ( hb_param( 1, HB_IT_DOUBLE ) != NULL )
      {
          __HB_RETPTRGC__( new QVariant( ( double ) hb_parnd( 1 ) ) );
      }  
      else if (hb_param( 1, HB_IT_LONG ) != NULL )
      {  
          __HB_RETPTRGC__( new QVariant( ( qlonglong ) hb_parnl( 1 ) ) );
      } 
      else
      {       
          __HB_RETPTRGC__( new QVariant( hb_parni( 1 ) ) );
      }
   }
   else if( hb_pcount() == 1 && HB_ISLOG( 1 ) )
   {
      __HB_RETPTRGC__( new QVariant( hb_parl( 1 ) ) );
   }
   else
   {
      __HB_RETPTRGC__( new QVariant() );
   }
}
</CODE>

<ENUMS>
enum Type { Invalid, BitArray, Bitmap, Bool, ..., UserType }
</ENUMS>

<PROTOS>
bool canConvert ( Type t ) const
void clear ()
bool convert ( Type t )
bool isNull () const
bool isValid () const
void setValue ( const T & value )
QBitArray toBitArray () const
bool toBool () const
QByteArray toByteArray () const
QChar toChar () const
QDate toDate () const
QDateTime toDateTime () const
double toDouble ( bool * ok = 0 ) const
QHash<QString, QVariant> toHash () const
int toInt ( bool * ok = 0 ) const
QLine toLine () const
QLineF toLineF () const
QList<QVariant> toList () const
QLocale toLocale () const
qlonglong toLongLong ( bool * ok = 0 ) const
QMap<QString, QVariant> toMap () const
QPoint toPoint () const
QPointF toPointF () const
QRect toRect () const
QRectF toRectF () const
QRegExp toRegExp () const
QSize toSize () const
QSizeF toSizeF () const
QString toString () const
QStringList toStringList () const
QTime toTime () const
uint toUInt ( bool * ok = 0 ) const
qulonglong toULongLong ( bool * ok = 0 ) const
QUrl toUrl () const
Type type () const
#
const char * typeName () const
#
int userType () const
#
# No Matching Function Call
#
//T value () const
#


QVariant fromValue ( const T & value )
Type nameToType ( const char * name )
const char * typeToName ( Type typ )
</PROTOS>

<SLOTS>
</SLOTS>

<SIGNALS>
</SIGNALS>
